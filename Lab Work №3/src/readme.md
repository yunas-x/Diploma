# Разработка BI-системы для исследования учебных планов образовательных программ университетов
## Имплементация принципов проектирования
### SRP
Для соблюдения принципа было решено разделить код на модули, каждый из которых выполняет ровно одну функциональность. Так, разделен уровень API, парсинг, валидация, загрузка в базу. Изменения в данных модулях будут производится только в случае изменения контракта API, форматов данных, правил валидации, структуры Базы Данных, соответственно.
### OCP
Данный принцип реализуется на уровне договоренностей (в том числе путем добавления _ в начало имени переменной). Так как Python не поддерживает сокрытие и позволяет именение классов и объектов в runtime, полностью гарантировать данный принцип в понимании статически-типизированных языков невозможно. Однако Python позволяет более гибко расширять функциональность объектов в runtime, платя за это возможностью модификации. В контексте программы принцип реализуется путем [полиморфизма](./loaders/models) и [миксинов](./parsers/mixins) (классов, которые "подмешивают" свою функциональность в основной).
### LSP
В целом, чтобы соблюсти данный принцип, нужно не злоупотреблять с наследованием. Так все интерфейсы (протоколы, миксины), используемые в коде, либо не содержат имплементации, либо содержат имплементацию, которая позднее не переопределяется, данный принцип соблюдается. В данном случае проблемы могли бы возникнуть, если бы мы смешали интерфейсы в один, после чего попытались бы его имплементировать как в парсере, так и в валидаторе. Это привело бы к тому, что часть методов интерфейса были бы в контексте реализации лишними.
### ISP
Так как Python нативно не поддерживает концепцию интерфейсов, мы будем использовать протоколы (аналог интерфейсов, поддерживающий утиную типизацию) и миксины (классы, не хранящие состояние).
Пример реализации данного подхода можно увидеть в пакете [parsers](./parsers). Так, протоколы и миксины разделены по функциональному назначению и выполняют каждый одну роль и реализуют один метод.
### DIP
Для соблюдения принципа зависимости (где это возможно), были спроектированы на абстракции. Это можно видеть в том числе в [Query](.loaders/orm/Query.py), где за счет проектирования зависимостей на абстракции избегается дублирование кода (которое могло бы быть, если бы мы писали операции отдельно для каждой таблицы). 
Там же вместо завимости на List используется зависимость на Iterable — более общий интерфейс, поддерживаемый языком с помощью т.н. dunder-методов.
Еще одним примером будет тип выходного значения у функции [choose_parser](./parsers/ParserFactory.py).
В случае класса Session и парсеров может быть реализован паттерн IoC (Inversion of Control) за счет выделения объекта [SessionMaker](./loaders/Context.py) и класса [ParserFactory](./parsers/ParserFactory.py).
### DRY
[InitFromJsonMixin](./parsers/mixins/InitFromJsonMixin.py) реализует функциональность конструктора из json-файла, которую можно переиспользовать (так как Mixin поддерживает kwargs).
Функции из [loaders/orm/Query](.loaders/orm/Query.py) так же спроектированы, чтобы обрабатывать любые модели, поскольку зависят от абстракций. Исключается дублирование для каждой модели.
### KISS
Наверное, самый яркий пример будет в [ParserFactory](./parsers/ParserFactory.py), где для работы фабрики используется дерево из словарей. Это позволяет сделать логику выбора парсера более наглядной и легкомодифицируемой. Также с целью соблюдения KISS было решено отказаться от библиотек, которые реализуют функциональность интерфейсов и ограничиться встроенными возможностями языка. По этой же причине было решено записать настройки в [Context](./loaders/Context.py), так как Python язык интерпретируемый и выигрыша от вынесения настроек отдельно от кода не подразумевает.
### YAGNI
Помимо указаного в документации было решено опустить [реализацию Select-операций](.loaders/orm/Query.py), поскольку на данный момент они не требуются.
